<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on LeaveIt</title>
    <link>https://example.com/posts/</link>
    <description>Recent content in Posts on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 18 Jul 2019 16:20:39 +0800</lastBuildDate>
    
	<atom:link href="https://example.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>org-mode_new</title>
      <link>https://example.com/2019/org-mode_new/</link>
      <pubDate>Thu, 18 Jul 2019 16:20:39 +0800</pubDate>
      
      <guid>https://example.com/2019/org-mode_new/</guid>
      <description>org-mode 基础操作 1. 标题 文章中的标题可以通过#+TITLE: 来设置.如
#+TITLE: org-mode
正文中的标题可以通过*,后面要空格,然后输入标题即可,一个*表示一级,最多10个
2. 段落 开始新的段落需要回车两次,当你回车一次,发布时,只相当于中间有一个空格,还有一种就是需要空格的地方输入
段落一
段落二
段落三
3. 字体 粗体
斜体
删除线
下划线 下标: H_2 O
4.列表  有序列表和无序列表2钟  无序列表以&amp;rsquo;-&amp;lsquo;,&amp;rsquo;+&amp;lsquo;或者&amp;rsquo;*&amp;lsquo;开头 有序列表以&amp;rsquo;1.&amp;lsquo;,&amp;lsquo;1)&amp;lsquo;开头 描述列表用&amp;rsquo;::&amp;rsquo;  注意事项  列表符号后面都要有空格 统计别的列表缩进要相同 如果想要加入统计的列表,可以M-RET 空2行之后列表结束,如果空一行执行M-RET,实际上还是输入统计项   5. 示例  Lord of the rings
my favorite scenes are(in this order)
 the sfdf  1111 2222  peter
 on  he makessfdf
   列表 嵌入元数据  内容元数据</description>
    </item>
    
    <item>
      <title>xgo</title>
      <link>https://example.com/2019/xgo/</link>
      <pubDate>Thu, 18 Jul 2019 15:44:11 +0800</pubDate>
      
      <guid>https://example.com/2019/xgo/</guid>
      <description> xgo 交叉编译 环境搭建  安装docker 下载 安装xgo镜像及编译指令 配置环境变量  1. 安装docker 平台选定为archlinux pacman -S docker
2. 下载go 3. 安装xgo docker镜像 xgo的docker镜像是我们真正的编译环境,Github地址
 安装xgo docker镜像,这个镜像大概5.G, docker pull karalabe/xgo-latest 安装xgo go get github.com/karalabe/xgo 启动docker docker run -i -t xog-latest /bin/bash 这里会要报错,关闭即可 连接docker容器 docker exec -it 容器的id /bin/bash 容器里面已经装好了xgo环境,直接git项目,编译即可  </description>
    </item>
    
    <item>
      <title>docker_new</title>
      <link>https://example.com/2019/docker_new/</link>
      <pubDate>Thu, 18 Jul 2019 15:24:26 +0800</pubDate>
      
      <guid>https://example.com/2019/docker_new/</guid>
      <description> docker 文件传输 docker容器和主机互相拷贝传输文件
docker cp 0000:/home/ /tmp/  宿主到docker容器
cp /tmp/ xxx:/home/  </description>
    </item>
    
    <item>
      <title>Java2</title>
      <link>https://example.com/2018/java2/</link>
      <pubDate>Mon, 30 Jul 2018 22:24:16 +0800</pubDate>
      
      <guid>https://example.com/2018/java2/</guid>
      <description> java基础 代码块 构造代码块  将代码块写在类中 构造代码块优先构造方法  静态代码块 static{ } 优先构造代码块,只执行一次  </description>
    </item>
    
    <item>
      <title>Markdown Mode</title>
      <link>https://example.com/2018/markdown-mode/</link>
      <pubDate>Sun, 29 Jul 2018 12:38:10 +0800</pubDate>
      
      <guid>https://example.com/2018/markdown-mode/</guid>
      <description> 用法 链接和图像 链接 markdown-mode
## 文字样式 ## 斜体 加粗 内联代码 标签
 引用代码块 C-c C-s q
 1 柱脚
 haha [return]   </description>
    </item>
    
    <item>
      <title>Java基础</title>
      <link>https://example.com/2018/java/</link>
      <pubDate>Sat, 28 Jul 2018 13:16:19 +0800</pubDate>
      
      <guid>https://example.com/2018/java/</guid>
      <description>Table of Contents  基础  数据类型  面向对象  封装 继承 多态 String类  设计模式  共享设计模式 关系映射 代码块   org-mode

基础 
数据类型 :重点: 选择数据类型原则
 整数用 int 小数用 double 如果描述日期数字或者表示文件大小使用 long 如果实现内容传递或者是编码转换使用 =byte =  
面向对象 
封装 构造方法
 在 new 的时候只会被调用一次 普通方法可以随意调用  匿名对象
 没有名字的对象,能用一次  
继承 
多态 
String类 相关方法 构造方法
 String(byte[] bytes): 将字符数组转成字符串 String(byte[] bytes, int offset, int length) String(byte[] bytes) : 通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 String(byte[] bytes, Charset charset) : 通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。 String(byte[] bytes, int offset, int length) : 通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。 String(byte[] bytes, int offset, int length, Charset charset) : 通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。  普通方法</description>
    </item>
    
    <item>
      <title>sublime</title>
      <link>https://example.com/2018/sublime/</link>
      <pubDate>Tue, 19 Jun 2018 20:27:00 +0000</pubDate>
      
      <guid>https://example.com/2018/sublime/</guid>
      <description>sublime ctrl+~ 复制 import urllib.request,os; pf = &amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &amp;lsquo;wb&amp;rsquo;).write(urllib.request.urlopen( &amp;lsquo;http://sublime.wbond.net/&#39; + pf.replace(&amp;rsquo; &amp;lsquo;,&amp;rsquo;%20&amp;rsquo;)).read())
package control 官网推荐 import urllib.request,os,hashlib; h = &amp;lsquo;6f4c264a24d933ce70df5dedcf1dcaee&amp;rsquo; + &amp;lsquo;ebe013ee18cced0ef93d5f746d80ef60&amp;rsquo;; pf = &amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &amp;lsquo;http://packagecontrol.io/&#39; + pf.replace(&amp;rsquo; &amp;lsquo;, &amp;lsquo;%20&amp;rsquo;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&amp;lsquo;Error validating download (got %s instead of %s), please try manual install&amp;rsquo; % (dh, h)) if dh !</description>
    </item>
    
    <item>
      <title>Sublime2</title>
      <link>https://example.com/2018/sublime2/</link>
      <pubDate>Tue, 19 Jun 2018 20:36:56 +0800</pubDate>
      
      <guid>https://example.com/2018/sublime2/</guid>
      <description>sublime ctrl+~ 复制 import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read()) package control 官网推荐 import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh !</description>
    </item>
    
    <item>
      <title>JSTL</title>
      <link>https://example.com/2018/jstl/</link>
      <pubDate>Fri, 25 May 2018 23:15:00 +0000</pubDate>
      
      <guid>https://example.com/2018/jstl/</guid>
      <description>定义标签 传统标签  写一个类实现tag接口 写一个tld文件,描述写好的类 在jsp页面引用tld文件并使用  简单标签  写一个类实现SimpleTag接口(继承SimpleTag接口的默认实现类SimpleTagSupport) 写一个tld文件,描述写好的类 在jsp页面中引入tld文件,就可以在jsp页面中使用自定义标签了  package com.yonyou; import java.io.IOException; import java.io.StringWriter; import javax.servlet.jsp.JspException; import javax.servlet.jsp.SkipPageException; import javax.servlet.jsp.tagext.JspFragment; import javax.servlet.jsp.tagext.SimpleTagSupport; public class demo02 extends SimpleTagSupport { @Override public void doTag() throws JspException, IOException { /* 控制标签体是否执行&amp;lt;c:if&amp;gt; //控制标签提不执行 ,什么都不做,就不执行 //控制标签执行*/ //JspFragment jspBody2 = getJspBody(); //jspBody2.invoke(getJspContext().getOut()); //jspBody2.invoke(null);//null则跟上面一样 //控制标签之后的内容是否执行 //什么在不做,标签后面的就会执行 //控制便签后面的内容不执行抛出SkipPageException异常 //throw new SkipPageException(); //控制标签体重复执行&amp;lt;c:foreach&amp;gt; //	for(int i=0;i&amp;lt;4;i++){ //	getJspBody().invoke(null); //	} // 修改标签体后输出&amp;lt;c:out&amp;gt; StringWriter stringWriter = new StringWriter(); JspFragment jspBody2 = getJspBody(); jspBody2.</description>
    </item>
    
    <item>
      <title>DBUTILs</title>
      <link>https://example.com/2018/dbutils/</link>
      <pubDate>Mon, 14 May 2018 21:21:00 +0000</pubDate>
      
      <guid>https://example.com/2018/dbutils/</guid>
      <description>元数据  DatabaseMetaData ParameterMetaData ?generateSimpleParameterMetadata=true ResultSetMetaData  DBUtils  DbUtils QueryRunner 两行代码搞定增删改查  QueryRunner() &amp;ndash;需要控制事务时,使用这组方法 QueryRunner(DataSource ds) &amp;ndash;不需要控制事务用这组方法    import java.sql.SQLException; import org.apache.commons.dbutils.DbUtils; import org.apache.commons.dbutils.QueryRunner; import org.junit.Test; import com.mchange.v2.c3p0.ComboPooledDataSource; public class demo04 { @Test public void test01() throws SQLException{ QueryRunner runner=new QueryRunner(new ComboPooledDataSource()); runner.update(&amp;quot;update dept set deptname=? where id =?&amp;quot;, &amp;quot;bb&amp;quot;,4); } } for (User u:query ) { System.out.println(u); } } catch (SQLException e) { e.printStackTrace(); } } @Test public void test5() throws SQLException { QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //返回结果及中的第一行指定列的值，单个查询 Object query = queryRunner.</description>
    </item>
    
    <item>
      <title>JDBC</title>
      <link>https://example.com/2018/jdbc/</link>
      <pubDate>Sat, 12 May 2018 19:57:00 +0000</pubDate>
      
      <guid>https://example.com/2018/jdbc/</guid>
      <description>连接  导包 mysql-connector-java-5.1.7-bin.jar 连接高版本mysql数据库，而驱动版本比较低则需要凑单jdbcurl中加入 字符集 jdbc:mysql:///day06?characterEncoding=utf-8 方法一  package com.yonyou; import java.sql.Connection; import java.sql.Driver; import java.sql.SQLException; import java.util.Properties; import org.junit.Test; /* * jdbc数据连接 * 导包 mysql-connector-java-5.1.7-bin.jar */ public class demo01 { //连接数据url private String url=&amp;quot;jdbc:mysql://localhost:3306/day0508&amp;quot;; @Test public void test01(){ //1.创建驱动程序对象 Driver driver=null; Properties properties = new Properties(); properties.setProperty(&amp;quot;user&amp;quot;, &amp;quot;root&amp;quot;); properties.setProperty(&amp;quot;password&amp;quot;, &amp;quot;admin&amp;quot;); //2.连接数据库 try { driver=new com.mysql.jdbc.Driver(); Connection connect = driver.connect(url, properties); System.out.println(connect); } catch (SQLException e) { e.printStackTrace(); } } }   方法二  @Test public void test03(){ try { Class.</description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>https://example.com/2018/mysql/</link>
      <pubDate>Tue, 08 May 2018 22:07:00 +0000</pubDate>
      
      <guid>https://example.com/2018/mysql/</guid>
      <description>命令 数据库管理  链接数据库 mysql -u root -p
 查看数据库 mysql&amp;gt; show databases;
 创建数据库 mysql&amp;gt; create database day0508; mysql&amp;gt; create database day050801 -&amp;gt; default character set utf8;
 删除数据库 mysql&amp;gt; drop database day050801;
 查看数据库的默认字符集 mysql&amp;gt; show create database day0508;
 修改数据库的默认字符集 mysql&amp;gt; alter database day0508 default character set gbk;
 使用数据库 mysql&amp;gt; use day0508;
表的操作 查看表 mysql&amp;gt; show tables;
 创建表 mysql&amp;gt; create table student( -&amp;gt; sid int , -&amp;gt; sname varchar(20), -&amp;gt; sage int);</description>
    </item>
    
    <item>
      <title>Windows的库</title>
      <link>https://example.com/2018/windows%E7%9A%84%E5%BA%93/</link>
      <pubDate>Tue, 08 May 2018 19:58:00 +0000</pubDate>
      
      <guid>https://example.com/2018/windows%E7%9A%84%E5%BA%93/</guid>
      <description> 静态库 - 扩展名lib文件,是不能被加载的程序,  动态库 - 扩展名dll的文件,可以被应用程序加载  </description>
    </item>
    
    <item>
      <title>按钮</title>
      <link>https://example.com/2018/%E6%8C%89%E9%92%AE/</link>
      <pubDate>Sun, 06 May 2018 12:01:00 +0000</pubDate>
      
      <guid>https://example.com/2018/%E6%8C%89%E9%92%AE/</guid>
      <description>分类  下压式按钮 PUSHBUTTON  正常下压式按钮 BS_PUSHBUTTON 三态式按钮 BS_3STATE|BS_AUTO3STATE  分组式按钮  BS_GROUPBOX  多选按钮 check box  BS_CHECKBOX|BS_AUTOCHECKBOX  点选按钮 Radio Box  BS_RADIOBUTTON|BS_AUTORADIOBUTTON    使用 下压式按钮的使用  创建按钮 相应按钮消息 WM_COMMAND  BN_CLICKED 消息,当点击按钮通过WM_COMMAND通知父窗口    通知消息 SenMessge  分组按钮  常用于对窗口内空间划分区域  多选按钮  创建使用BS_CHECKBOX|BS_AUTOCHECKBOX  BS_AUTOCHECKBOX 选择状态系统自动维护  命令响应 -BN_CLICKED 同桌wm_command消息 通知消息  BM_GETCHECK 获取当前按钮被选择的状态 BM_SETCHECK 设置当前按钮被选择的状态,wParam用于设置状态    单选按钮  创建使用BS_RADIOBUTTON|BS_AUTORADIBUTTON 可以通过WS_GROUP将单选分组  #include&amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>头文件</title>
      <link>https://example.com/2018/%E5%A4%B4%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 01 May 2018 19:49:00 +0000</pubDate>
      
      <guid>https://example.com/2018/%E5%A4%B4%E6%96%87%E4%BB%B6/</guid>
      <description>全局变量重复定义，fatal error LNK1169: 找到一个或多个多重定义的符号 1.在GlobeValue.h中定义了一个变量：
char gl_UID[256];
2.在b.cpp和e.cpp中分别引用GlobeValue.h,并且使用gl_UID的全局变量，
结果出现：fatal error LNK1169: 找到一个或多个多重定义的符号 的错误。
错误的原因：因为在gl_UID全局变量是在GlobeValue.h中定义的，所以呢，每次包含一次这个头文件时，相当于又定义了一个这样的变量。
正确的代码书写方法是： 在GlobeValue.h中使用extern char gl_UID,申明这个变量，在b.cpp中定义这个变量char gl_UID[256]，在e.cpp中不需要定义。这样，每次包含这个头文件，遇到extern时，编译器就知道在别处存在这个变量了，就不会重新定义了。</description>
    </item>
    
    <item>
      <title>win32</title>
      <link>https://example.com/2018/win32/</link>
      <pubDate>Tue, 01 May 2018 18:47:00 +0000</pubDate>
      
      <guid>https://example.com/2018/win32/</guid>
      <description>窗口注册和创建  WinMain入口函数的定义 windowProc函数的定义 注册窗口类 RegisterClass|RegisterClassEx 窗口创建 CreateWindow/CreateWindowEx 窗口的显示和刷新ShowWindow|UpdateWindow 消息处理 GetMessage|DispatchMessage 窗口退出 WM_DESTROY|PostQuitMessage  窗口的注册  窗口类的分类
 系统全局的窗口类,比如按钮,文本,编辑框,直接使用,不需要注册 应用程序的全局窗口类,可以在exe和dll中使用的窗口类, 局部窗口类,只能在本模块中使用的窗口类   实现窗口类的注册
 系统全局的窗口类,直接使用 应用程序的全局窗口,注册时需要增加CS_GLOBALCLASS定义方式WNDCLASS wc{0}; wc.style=CS_GLOBALCLASS; RegisterClass(&amp;amp;wc); 局部窗口类,不能增加CS_GLOBALCLASS定义   typedef struct _WNDCLASSEX { UINT cbSize; //结构体的大小 UINT style; WNDPROC lpfnWndProc; int cbClsExtra; int cbWndExtra; HANDLE hInstance; HICON hIcon; HCURSOR hCursor; HBRUSH hbrBackground; LPCTSTR lpszMenuName; LPCTSTR lpszClassName; HICON hIconSm; } WNDCLASSEX;  窗口类的风格  CS_HREDRAW 窗口水平变化,重新绘制窗口 CS_VREDRAW 窗口垂直变化,重新绘制窗口 CS_GLOBALCLASS 创建应用程序全局窗口类 CS_DBCLICK 窗口可以接受鼠标双击消息 CS_CLASSDC 所有这种类型的窗口使用同一个dc(输出设备) CS_OWNDC 每个窗口拥有自己的dc CS_PARENTDC 使用父窗口的dc CS_NOCLOSE 禁止关闭命令没有小红X  窗口类的附加数据  在窗口类的数据信息中添加自己信息, cbClsExtra用于添加信息的内存大小 SetClassLong 将信息保存到内存中 GetClassLong 将信息从内存中取出  窗口的附加数据  在窗口的数据信息中添加自己信息, cbWndExtra用于添加信息的内存大小 SetWindowLong 将信息保存到内存中 GetWindowLong 将信息从内存中取出  窗口类的相关函数  RegisterClass|RegisterClassEX 注册 UnregisterClass 注销 GetClassInfo|GetClassInfoEx 获取信息 GetClassName 获取窗口的窗口类名称 GetClassLong|SetClasslONG 附加数据的设置和获取 GetWindowLong|SetWinodwLong 窗口的附加数据设置和获取  创建窗口时如何定位窗口类  先查找应用程序局部的窗口类 如果找到了名称一致的窗口类,会比较HINSTANCE句柄,如果相等,就使用找到的窗口类的信息创建窗口,如果不同,继续查找 如果为找到名称一致的窗口类,会继续在应用程序全局窗口类中查找执行4,否则执行5 全局窗口类找到一致的,使用找到的窗口类信息创建窗口 没找到,会去系统的全局窗口类中查找,找到创建窗口,找不到返回null  窗口创建 函数  CreateWindowEx|CreateWindow  HWND CreateWindowEx( DWORD dwExStyle, // 扩展样式 LPCTSTR lpClassName, // pointer to registered class name LPCTSTR lpWindowName, // pointer to window name DWORD dwStyle, // window style int x, // horizontal position of window int y, // vertical position of window int nWidth, // window width int nHeight, // window height HWND hWndParent, // handle to parent or owner window HMENU hMenu, // handle to menu, or child-window identifier HINSTANCE hInstance, // handle to application instance LPVOID lpParam // pointer to window-creation data );   窗口风格和扩展风格  窗口风格 ws_xxx 扩展风格 WS_EX_XXX WS_OVERLAPPED 窗口,层叠窗口 WS_POPUP 弹出式窗口 WS_CHILD 子窗口  父窗口和子窗口  WS_CHILD,将窗口的风格 CreateWindow时,可以指定父窗口指定父窗口 SetParent 设置父窗口  MDI窗口的创建  创建主窗口 MDICLIENT窗口 创建一个MDI子窗口  #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>JSP</title>
      <link>https://example.com/2018/jsp/</link>
      <pubDate>Tue, 01 May 2018 15:41:00 +0000</pubDate>
      
      <guid>https://example.com/2018/jsp/</guid>
      <description>特点  jsp运行必须交给tomcat服务器 ,tomcat的work目录,存放jsp运行时的临时文件  执行过程  tomcat扫描jsp文件在work目录包jsp文件翻译成java源文件. tomcat服务器会把java源文件编程成字节码文件 返回构造类对象 调用相应方法  jsp语法  jsp模板 表达式  &amp;lt;%=变量或表达式%&amp;gt; 输出表达式的结果或值   脚本  &amp;lt;% java 代码 %&amp;gt;   声明 注释 jsp指令  include    原理是吧被包含的页面内容反映到包含页面中,合并成翻译成一个java源文件,再编译运行,这种包含叫静态包含
如果使用静态包含,被包含页面中不需要出现全局的html标签
&amp;lt;%@include file=&amp;quot;&amp;quot; %&amp;gt;   taglib page   告诉tomcat服务器如何翻译jsp文件
&amp;lt;%@ page language=&amp;quot;java&amp;quot; 用java语言翻译 import &amp;quot;java.util.*&amp;quot; 导包,多个用逗号分隔 pageEncodeing=&amp;quot;utf-8&amp;quot; 使用服务器用什么编码翻译 contentType=&amp;quot;text/html;charset=utf-8&amp;quot; 服务器发送浏览器的数据类型和编码 errorPage=&amp;quot;error.jsp&amp;quot; isErrorPage=&amp;quot;false&amp;quot; buffer=&amp;quot;8kb&amp;quot; session=&amp;quot;true&amp;quot; isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;   taglib 指令  ### jsp内置对象</description>
    </item>
    
    <item>
      <title>servlet</title>
      <link>https://example.com/2018/servlet/</link>
      <pubDate>Mon, 30 Apr 2018 10:27:00 +0000</pubDate>
      
      <guid>https://example.com/2018/servlet/</guid>
      <description>生命周期  输入url,会在应用目录的web.xml中查找是否有匹配的url-pattern的内容 如果找到匹配的url-pattern,则使用当前的servlet-name的名称到web.xml文件中查找是否相同的servlet配置,如果没有匹配到,则交给defalutservlet处理 如果找到,则取出相对应的serlvert配置信息中的servlet-class 内容,然后通过反射创建对象,并调用相关方法  生命周期 servlet程序是有tomcat服务器控制
 构造方法:创建servlet对象的时候调用,第一次访问,servlet的时候创建servlet对象,会调用有参的,只调用1次, init方法:创建完servlet对象的时候 ,只调用1次 service方法:每次发出请求时调用,每次请求调用一次 destroy:销毁serlvet对象的时候,停止服务器或者重新部署web应用的时候销毁servlet对象  web.xml匹配规则  精确匹配 /aa | /aa/bb 模糊匹配 /* | *.后缀 \ *.do  默认的 / 缺省servlet 解析web应用的静态资源文件 优先级 精确匹配 优先  servlet自动加载 在servlet的配置文件中加上load-on-startup即可
域对象 HttpServletRequest 请求对象,获取请求信息
HttpServletResponse 响应对象,设置响应对象
ServletConfig servlet配置对象
创建时机: 在创建完servlet对象后,在调用init方法之前创建
得到对象:直接从有参数的init方法得到
init-para要放在load-on-startup上边
web.xml &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;path&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;c:/1.txt&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!-- 让servlet自动加载 &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;--&amp;gt; String initParameter = config.getInitParameter(&amp;quot;path&amp;quot;); response.getWriter().write(initParameter);  ServletContext Servlet的上下文对象
得到web应用路径: java.lang.String getContextPath() rqeust.</description>
    </item>
    
    <item>
      <title>字符编码</title>
      <link>https://example.com/2018/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sun, 29 Apr 2018 17:13:00 +0000</pubDate>
      
      <guid>https://example.com/2018/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</guid>
      <description>编码  ASCII 0-127 7为表示 ASCII 扩展码 0-255 8位表示,代码页:通过代码页来切换对应的字符 双字节字符集 DBCS,使用一个或2个字节表示字符
A中B国 1 2 1 2 A:0X41 中:0x5051 B:0X42 国 0x5253 1 2 3 4 5 6 0x41 0x50 0x51 0x42 0x52 0x53  Unicode 编码
 全部使用2个字节表示字符,内存/硬盘等资源占用变大
A 中 B 国 2 2 2 2 A:0X0041 中:0x5051 B:0X0042 国 0x5253 1 2 3 4 5 6 7 8 0x00 0x41 0x50 0x51 0x00 0x42 0x52 0x53    C语言和编码  单字节的字符和字符串  char cText=&#39;A&#39;; char *pszText=&amp;quot;abcd&amp;quot;;   双字节的字符|宽字节  //双字节字符 void C_wchar() { wchar_t cText=&#39;A&#39;; wchar_t *pszText=L&amp;quot;abcd&amp;quot;; //打印宽字节 wprintf(L&amp;quot;%s\n&amp;quot;,pszText); //获取宽字节长度 int nlen=wcslen(pszText); printf(&amp;quot;%d\n&amp;quot;,nlen); }   相关函数</description>
    </item>
    
    <item>
      <title>tomcat</title>
      <link>https://example.com/2018/tomcat/</link>
      <pubDate>Fri, 27 Apr 2018 23:04:00 +0000</pubDate>
      
      <guid>https://example.com/2018/tomcat/</guid>
      <description> 开发动态资源 静态资源和动态资源 Servlet  特点  普通的java类,继承HttpServlet类,覆盖doGet方法 Servlet类只能交给tomcat服务器运行 jar 包 servlet-api.jar    手动编写步骤    </description>
    </item>
    
    <item>
      <title>QT5</title>
      <link>https://example.com/2018/qt/</link>
      <pubDate>Fri, 27 Apr 2018 22:09:00 +0000</pubDate>
      
      <guid>https://example.com/2018/qt/</guid>
      <description>hello hello.pro SOURCES += \ hello.cpp QT+=widgets gui main.cpp /*应用程序抽象类*/ #include&amp;lt;QApplication&amp;gt; /*窗口类*/ #include&amp;lt;QWidget&amp;gt; int main(int argc,char *argv[]){ QApplication app(argc,argv); QWidget w; w.setWindowTitle(&amp;quot;hello world&amp;quot;); w.show(); /*exec 中有一个消息循环*/ return app.exec(); }  手动编译qt文件 main.cpp #include&amp;lt;QApplication&amp;gt; #include&amp;lt;QLabel&amp;gt; int main(int argc,char **argv){ QApplication app(argc,argv); QLabel *label=new QLabel; label-&amp;gt;setText(&amp;quot;hello qt&amp;quot;); label-&amp;gt;show(); return app.exec(); } 找到qt里面的 MinGW 4.8 (32-bit) Qt 5.2.0 for Desktop (MinGW 4.8 32 bit) 控制台 1. D:\Workspaces\QT\day0429\demo01&amp;gt;qmake -project 生成 demo01.pro 包 2 D:\Workspaces\QT\day0429\demo01&amp;gt;qmake 生成makefile 3.</description>
    </item>
    
    <item>
      <title>对话框</title>
      <link>https://example.com/2018/%E5%AF%B9%E8%AF%9D%E6%A1%86/</link>
      <pubDate>Thu, 26 Apr 2018 20:21:00 +0000</pubDate>
      
      <guid>https://example.com/2018/%E5%AF%B9%E8%AF%9D%E6%A1%86/</guid>
      <description> 分类  无模式的对话框  对话框显示后,不影响其他窗口的使用 2. 有模式的对话框
对话框显示后,会将其他窗口禁止输入操作
1. 添加对话框资源 2. 定义对话框窗口处理函数 3. 创建对话框 4. 关闭对话框  使用方式  对话框的窗口处理函数 注册窗口(可选) 创建对话框 4.关闭对话框  对话框资源 </description>
    </item>
    
    <item>
      <title>位图</title>
      <link>https://example.com/2018/%E4%BD%8D%E5%9B%BE/</link>
      <pubDate>Thu, 26 Apr 2018 19:53:00 +0000</pubDate>
      
      <guid>https://example.com/2018/%E4%BD%8D%E5%9B%BE/</guid>
      <description> 位图 位图的使用  加载位图 创建放置位图的dc 将位图放入创建的dc中 绘制位图到当前dc中 取出位图 删除创建的位图 删除位图  </description>
    </item>
    
    <item>
      <title>绘图</title>
      <link>https://example.com/2018/%E7%BB%98%E5%9B%BE/</link>
      <pubDate>Mon, 23 Apr 2018 22:21:00 +0000</pubDate>
      
      <guid>https://example.com/2018/%E7%BB%98%E5%9B%BE/</guid>
      <description>绘图 图形绘制  图形绘图的方式,获取到绘图句柄,设备描述表(DC),使用相应的绘图的api,  颜色 RGB三色,每种颜色8位,24位颜色
32位颜色:颜色数量24位颜色,多出来的8位,表示一个灰度
16位颜色:556表示的方式,颜色的数量2的16次方
Win32下 颜色的定义 COLORREF(DWORD)
COLORREF nColor=RGB(0,0,0);
COLORREF nColor=RGB(255,255,255);
从一个颜色重获取RGB三色
int nBlue=GetBValue(nColor);
点的绘制和获取 绘制 COLORREF SetPixel( HDC hdc, // Dc的句柄 int X, // x坐标 int Y, // y坐标 COLORREF crColor // 颜色 ); 获取 COLORREF GetPixel( HDC hdc, // handle to device context int XPos, // x-coordinate of pixel int nYPos // y-coordinate of pixel ); void DrawPixel(HDC hDC){ COLORREF nColor=RGB(255,0,0); SetPixel(hDC,100,100,nColor); } void GetPixelColor(HDC hDC) { COLORREF nColor=GetPixel(hDC,100,100); int nRed=GetRValue(nColor); int nGreen=GetGValue(nColor); int nBlue=GetBValue(nColor); CHAR szText[200]={0}; sprintf(szText,&amp;quot;%d %d %d&amp;quot;,nRed,nGreen,nBlue); PrintLogln(szText); }  线的绘制  MoveToEx 移动当前起始点到制定位置 LineTo 绘制执行到制定位置  void DrawLine(HDC hDC){ MoveToEx(hDC,0,0,NULL); LineTo(hDC,500,500); }  弧形 BOOL AngleArc( HDC hdc, // handle to device context int X, // x-coordinate of circle&#39;s center int Y, // y-coordinate of circle&#39;s center DWORD dwRadius, // circle&#39;s radius 圆的半径 FLOAT eStartAngle, // arc&#39;s start angle 开始角度 FLOAT eSweepAngle // arc&#39;s sweep angle 夹角 ); 设置开始会圆的方向 int SetArcDirection( HDC hdc, // handle to the device context int ArcDirection // specifies the new arc direction ); BOOL Arc( HDC hdc, // handle to device context int nLeftRect, // 外切矩形左上x坐标 int nTopRect, // 外切矩形左上y坐标 int nRightRect, // 外切矩形右下x坐标 int nBottomRect, // 外切矩形右下y坐标 int nXStartArc, // 圆心到弧左边或右边的直线的点 int nYStartArc, // 圆心到弧左边或右边的直线的点 int nXEndArc, // 圆心到弧左边或右边的直线的点 int nYEndArc //圆心到弧左边或右边的直线的点 ); void DrawARC(HDC hDC){ SetArcDirection(hDC,AD_CLOCKWISE); Arc(hDC,400,400,500,500,400,400,500,400); /*MoveToEx(hDC,200,200,NULL); AngleArc(hDC,200,200,100,60,120);*/ }  折线 PolyLine</description>
    </item>
    
    <item>
      <title>XML</title>
      <link>https://example.com/2018/xml/</link>
      <pubDate>Sun, 22 Apr 2018 22:14:00 +0000</pubDate>
      
      <guid>https://example.com/2018/xml/</guid>
      <description>xml解析 解析工具 Dom解析工具
 jaxp JDOM工具 DOM4J工具  SAX 解析
 SAX解析工具,  节点信息: Node 节点名称 节点类型 nodeIterator 标签节点: Element 标签名 方法 1. getRootElement 2. elementIterator 3. elements 属性节点:Attribute 属性名称 属性值 方法: 1. contactEle.attributeValue(&amp;quot;id&amp;quot;); 2. contactEle.attribute(&amp;quot;id&amp;quot;); 3. contactEle.attributes(); 4. contactEle.attributeIterator() 文本节点: Text 文本内容 方法 1.doc.getRootElement().element(&amp;quot;contact&amp;quot;).element(&amp;quot;name&amp;quot;); 2. doc.getRootElement().element(&amp;quot;contact&amp;quot;).elementText(&amp;quot;name&amp;quot;);  DOM4J解析  导包  dom4j-1.6.1.jar
 获取Document文档  /*new File(&amp;quot;.&amp;quot;).getAbsolutePath() D:\Workspaces\MyEclipse 8.5\day0422\.*/ /* * 读取xml内容 */ package com.yonyou.demo01; import java.io.File; import java.</description>
    </item>
    
    <item>
      <title>win32资源</title>
      <link>https://example.com/2018/win32%E8%B5%84%E6%BA%90/</link>
      <pubDate>Sun, 22 Apr 2018 11:55:00 +0000</pubDate>
      
      <guid>https://example.com/2018/win32%E8%B5%84%E6%BA%90/</guid>
      <description>资源文件 图标,光标,字符串,菜单,加速jm
ICON 光标资源 #define _WIN32_WINNT 0x0400 //¹öÂÖÏûÏ¢±ØÐë¼ÓÔÚwindows.hÖ®Ç°¼Ó #include &amp;lt;windows.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;quot;resource.h&amp;quot; #define WM_FIRSTMSG (WM_USER+1)//×Ô¶¨ÒåÏûÏ¢ HINSTANCE g_hInst=NULL; HANDLE g_hStdOut=NULL; int g_nXPos,g_nYPos; int g_nX1Rect,g_nY1Rect; int g_nX2Rect,g_nY2Rect; void PrintLog(LPSTR pszLog){ WriteConsole(g_hStdOut,pszLog,strlen(pszLog),NULL,NULL); } void PrintLogln(LPSTR pszLog){ WriteConsole(g_hStdOut,pszLog,strlen(pszLog),NULL,NULL); WriteConsole(g_hStdOut,&amp;quot;\r\n&amp;quot;,strlen(&amp;quot;\r\n&amp;quot;),NULL,NULL); } BOOL OnSetCursor(HWND hWnd,UINT nMsg,WPARAM wParam,LPARAM lParam) { int nHitText=LOWORD(lParam); if(HTCLIENT!=nHitText){ return FALSE; } //获取窗口的客户区 RECT rcClient={0}; GetClientRect(hWnd,&amp;amp;rcClient); //获得当前光标的位置 POINT ptPos={0}; GetCursorPos(&amp;amp;ptPos); ScreenToClient(hWnd,&amp;amp;ptPos); //根据位置设置光标 HCURSOR hCursor=NULL; if(ptPos.x&amp;lt;rcClient.right/2){ if(ptPos.y&amp;lt;rcClient.bottom/2){ //左上 hCursor=LoadCursor(NULL,IDC_SIZEALL); }else{ //左下 hCursor=LoadCursor(NULL,IDC_HELP); } }else{ if(ptPos.</description>
    </item>
    
    <item>
      <title>Win32菜单</title>
      <link>https://example.com/2018/win32%E5%9B%BE%E5%BD%A2/</link>
      <pubDate>Sat, 21 Apr 2018 11:37:00 +0000</pubDate>
      
      <guid>https://example.com/2018/win32%E5%9B%BE%E5%BD%A2/</guid>
      <description>菜单 菜单的使用  菜单的创建  菜单创建后,会返回HMENU句柄 - MENU 菜单 CreateMenu - POPUPMENU 弹出式菜单 CreatePopupMenu
菜单项 每个菜单项会有一个id号,可以根据这个id执行不同的参数 2. 菜单的使用 - CreateMenu
- AppenedMenu 增加菜单项 ```c BOOL WINAPI AppendMenu(  In HMENU hMenu, In UINT uFlags, In UINT_PTR uIDNewItem, _Inopt LPCTSTR lpNewItem ); ``` - CreatePopupMenu
#define _WIN32_WINNT 0x0400 //¹öÂÖÏûÏ¢±ØÐë¼ÓÔÚwindows.hÖ®Ç°¼Ó #include &amp;lt;windows.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define WM_FIRSTMSG (WM_USER+1)//×Ô¶¨ÒåÏûÏ¢ HINSTANCE g_hInst=NULL; HANDLE g_hStdOut=NULL; int g_nXPos,g_nYPos; int g_nX1Rect,g_nY1Rect; int g_nX2Rect,g_nY2Rect; BOOL OnSysCommand(HWND hWnd,UINT nMsg,WPARAM wParam,LPARAM lParam){ switch(wParam) { case SC_CLOSE: if(IDOK==MessageBox(NULL,&amp;quot;ÊÇ·ñ½«ÎÄ¼þ´æÅÌ&amp;quot;,&amp;quot;OnSysCommand&amp;quot;,MB_OKCANCEL|MB_ICONWARNING)){ return TRUE; }else{ return FALSE; } break; } } void PrintLog(LPSTR pszLog){ WriteConsole(g_hStdOut,pszLog,strlen(pszLog),NULL,NULL); } void PrintLogln(LPSTR pszLog){ WriteConsole(g_hStdOut,pszLog,strlen(pszLog),NULL,NULL); WriteConsole(g_hStdOut,&amp;quot;\r\n&amp;quot;,strlen(&amp;quot;\r\n&amp;quot;),NULL,NULL); } void OnCreater(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam) { HMENU hMenu=CreateMenu(); HMENU hFileMenu=CreatePopupMenu(); AppendMenu(hFileMenu,MF_STRING|MF_CHECKED,1001,&amp;quot;新建(&amp;amp;N)&amp;quot;); //分割线 AppendMenu(hFileMenu,MF_SEPARATOR,0,NULL); AppendMenu(hFileMenu,MF_STRING,1002,&amp;quot;退出(&amp;amp;Q)&amp;quot;); AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT)hFileMenu,&amp;quot;文件(&amp;amp;F)&amp;quot;); //快捷键alt+f HMENU hEditMenu=CreatePopupMenu(); AppendMenu(hEditMenu,MF_STRING,1003,&amp;quot;剪切(&amp;amp;x)&amp;quot;); AppendMenu(hEditMenu,MF_STRING,1004,&amp;quot;拷贝(&amp;amp;C)&amp;quot;); AppendMenu(hEditMenu,MF_STRING,1005,&amp;quot;粘贴(&amp;amp;v)&amp;quot;); AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT)hEditMenu,&amp;quot;编辑(&amp;amp;E)&amp;quot;); HMENU hHelpMenu=CreatePopupMenu(); AppendMenu(hHelpMenu,MF_STRING,1006,&amp;quot;关于(&amp;amp;A)&amp;quot;); AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT)hHelpMenu,&amp;quot;帮助(&amp;amp;H)&amp;quot;); SetMenu(hWnd,hMenu); } LRESULT CALLBACK WndProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam ) { switch (nMsg) { case WM_CREATE: OnCreater(hWnd,nMsg,wParam,lParam); break; case WM_DESTROY: PostQuitMessage(0); //wm_quit return 0; } return DefWindowProc(hWnd,nMsg,wParam,lParam); } BOOL RegisterWnd(LPSTR pszClassName){ WNDCLASSEX wce ={0}; wce.</description>
    </item>
    
    <item>
      <title>Win32消息机制</title>
      <link>https://example.com/2018/win32%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 16 Apr 2018 22:26:00 +0000</pubDate>
      
      <guid>https://example.com/2018/win32%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</guid>
      <description>消息机制 过程驱动  程序是安装我们预定好的顺序执行
事件驱动 程序的执行顺序是无序的,某个时间点所执行的代码,是由外界通知
 win32的消息机制,就是事件驱动
win32消息程序 win32窗口注册 win32窗口创建 win32消息循环 GetMessage  BOOL GetMessage（LPMSG lpMsg，//存放获取到的消息数据 HWND hWnd， //获取消息的窗口句柄 UINT wMsgFilterMin，//消息过滤的起始消息 UINT wMsgFilterMax); //消息过滤的终止消息 返回值BOOL:成功获取消息,返回TRUE, 当获取WM_QUIT消息时,返回fase switch (nMsg) { case:WM_DESTROY://窗口销毁时的消息 PostQuitMessage(0); //wm_quit return 0; } MSG - 由系统填写 hWnd - 接收由hWnd指定的窗口的消息  TranslateMessage  将键盘消息转换成字符消息 首先检查是否为键盘按键消息 如果发现是键盘按键消息,将会根据按键产生一个字符消息,在下一个GetMessage执行之前,会收到这个消息 如果未发现,不做处理  DispatchMessage  根据消息数据内窗口句柄,找到这个窗口的处理函数,并调用,进行消息处理 如果msg中,hwnd窗口句柄为空,则不做处理 ```c //消息处理函数 LRESULT CALLBACK WndProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam ) { switch (nMsg) { case:WM_DESTROY://窗口销毁时的消息 PostQuitMessage(0); //wm_quit return 0; }  	//使用系统函数处理我们未处理的消息类型 return DefWindowProc(hWnd,nMsg,wParam,lParam);</description>
    </item>
    
    <item>
      <title>路径问题</title>
      <link>https://example.com/2018/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 16 Apr 2018 22:12:00 +0000</pubDate>
      
      <guid>https://example.com/2018/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description> 当前路径 类文件路径  classpath路径  package com.yonyou.demo01; import java.io.File; import java.io.InputStream; public class test03 { public static void main(String[] args) { //获取类路径 InputStream resourceAsStream = test03.class.getResourceAsStream(&amp;quot;/&amp;quot;); // &amp;quot;/&amp;quot; 代表了classpath的路径 //获取当前路径 File file = new File(&amp;quot;.&amp;quot;); String absolutePath = file.getAbsolutePath(); System.out.println(absolutePath); } }  </description>
    </item>
    
    <item>
      <title>BenUtils</title>
      <link>https://example.com/2018/benutils/</link>
      <pubDate>Mon, 16 Apr 2018 21:30:00 +0000</pubDate>
      
      <guid>https://example.com/2018/benutils/</guid>
      <description>内省 package com.yonyou.demo01; import java.beans.BeanInfo; import java.beans.IntrospectionException; import java.beans.Introspector; import java.beans.PropertyDescriptor; import java.lang.reflect.Method; import org.junit.Test; public class test01 { public static void main(String[] args) { } @Test public void getAllProperty() throws Exception{ //Introspector 内省类 BeanInfo beanInfo = Introspector.getBeanInfo(Person.class); //获取所有属性描述器 PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { System.out.println(propertyDescriptor.getReadMethod()); //get方法 } } @Test public void testProperty() throws Exception{ Person p=new Person(); //属性描述器 PropertyDescriptor propertyDescriptor = new PropertyDescriptor(&amp;quot;name&amp;quot;, Person.class); //获取属性对应的get或set方法设置或者获取属性 Method writeMethod = propertyDescriptor.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/1/lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/1/lua/</guid>
      <description> lua </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/1/pojie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/1/pojie/</guid>
      <description> pojie 脱壳 去广告 1. 工具 1. C32ASM 2. Restorator 2009 3. ProcMon 4. ProcExp 查看那个窗口属于哪个进程  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/1/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/1/test/</guid>
      <description> Table of Contents  我是主题  
我是主题 我是正文
 我是列表1 2 3  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/1/xpath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/1/xpath/</guid>
      <description>导包 pip3 install lxml from lxml import etree 定位  通过id定位 xpat=&amp;ldquo;//a[@id=&amp;lsquo;xxx&amp;rsquo;]&amp;rdquo; 通过属性定位 xpath=&amp;ldquo;//a[@name=&amp;ldquo;]&amp;rdquo; 多个条件 xpath=&amp;ldquo;//a[@type=&amp;rdquo; and @name=&amp;ldquo;]&amp;rdquo; text()方法定位 xpath=&amp;ldquo;//a[text()=&amp;ldquo;]&amp;rdquo; 模糊定位 xpath=&amp;ldquo;//a[contains(@属性，&amp;rsquo;属性值&amp;rsquo;)]&amp;rdquo; 获取指定属性的属性值 xpath(&amp;lsquo;//input[@name=&amp;ldquo;SERVERTYPE&amp;rdquo;]&amp;lsquo;) 获取a标签中href中的值 html.xpath(&amp;lsquo;//li/a//@href&amp;rsquo;)   多线程 from concurrent.futures import ThreadPoolExecutor ProcessPoolExecutor 1. map python from concurrent import futures urls=[1,2,3,4,5] def downloads(urls): print(&amp;quot;正在下载......&amp;quot;) return &amp;quot;ok&amp;quot; with futures.ThreadPoolExecutor(10) as ex: res=ex.map(downloads,urls) for i in res: print(i) 
 带回调函数
t.submit(get_page, url).add_done_callback(parse_page)
from concurrent import futures urls=[1,2,3,4,5] def downloads(urls): print(&amp;quot;正在下载.</description>
    </item>
    
  </channel>
</rss>